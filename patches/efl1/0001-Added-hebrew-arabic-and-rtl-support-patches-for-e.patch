From 8fc29c3d86562a1fed6a79d11fede5d142168626 Mon Sep 17 00:00:00 2001
From: Tom Hacohen <tom@nospam>
Date: Sat, 11 Apr 2009 16:30:55 +0300
Subject: [PATCH] Fixed hebrew, arabic and rtl support

---
 recipes/efl1/evas.inc                             |    4 +-
 .../efl1/evas/add_rtl_compositing_arabic.patch     |  626 ++++++++++++++++++++
 recipes/efl1/evas_svn.bb                          |    2 +-
 3 files changed, 630 insertions(+), 2 deletions(-)
 create mode 100644 recipes/efl1/evas/add_rtl_compositing_arabic.patch

diff --git a/recipes/efl1/evas.inc b/recipes/efl1/evas.inc
index ff7a184..7c16863 100644
--- a/recipes/efl1/evas.inc
+++ b/recipes/efl1/evas.inc
@@ -10,6 +10,8 @@ ARM_INSTRUCTION_SET = "arm"
 
 inherit efl
 
+SRC_URI_append = " file://add_rtl_compositing_arabic.patch;patch=0 "
+
 FILESDIR = "${@os.path.dirname(bb.data.getVar('FILE',d,1))}/evas"
 EXTRA_OECONF = "<override me>"
 
diff --git a/recipes/efl1/evas/add_rtl_compositing_arabic.patch b/recipes/efl1/evas/add_rtl_compositing_arabic.patch
new file mode 100644
index 0000000..fd1364f
--- /dev/null
+++ b/recipes/efl1/evas/add_rtl_compositing_arabic.patch
@@ -0,0 +1,626 @@
+Index: evas/src/lib/engines/common/evas_font_draw.c
+===================================================================
+--- evas/src/lib/engines/common/evas_font_draw.c	(revision 39827)
++++ evas/src/lib/engines/common/evas_font_draw.c	(working copy)
+@@ -2,9 +2,17 @@
+  * vim:ts=8:sw=3:sts=8:noexpandtab:cino=>5n-3f0^-2{2
+  */
+ 
++/* Internationalization (RTL and Arabic contextualizing)
++ * was added by Tom Hacohen (tom@stosb.com)
++ */
++
++
+ #include "evas_common.h"
+ #include "evas_blend_private.h"
+ 
++#include "evas_intl_utils.h" /*defines INTERNATIONAL_SUPPORT if possible */
++
++
+ EAPI RGBA_Font_Glyph *
+ evas_common_font_int_cache_glyph_get(RGBA_Font_Int *fi, FT_UInt index)
+ {
+@@ -166,6 +174,8 @@
+    return 0;
+ }
+ 
++
++
+ static void
+ evas_common_font_draw_internal(RGBA_Image *dst, RGBA_Draw_Context *dc, RGBA_Font *fn, int x, int y, const char *text,
+                                RGBA_Gfx_Func func, int ext_x, int ext_y, int ext_w, int ext_h, RGBA_Font_Int *fi,
+@@ -178,12 +188,26 @@
+    FT_UInt prev_index;
+    DATA32 *im;
+    int c;
++   int char_index = 0; /* the index of the current char */
++   
++#ifdef INTERNATIONAL_SUPPORT
++   int bidi_err = 0;
++   /*FIXME: should get the direction by parmater */
++   FriBidiCharType direction = FRIBIDI_TYPE_ON;
++   FriBidiLevel *level_list;
+ 
++   /* change the text to visual ordering and update the level list */
++   {
++      char *tmp = evas_intl_utf8_to_visual(text, &bidi_err, &direction, &level_list);
++      text = (tmp) ? tmp : text;
++   }
++#endif
++
+    pen_x = x;
+    pen_y = y;
+    prev_index = 0;
+    im = dst->image.data;
+-   for (c = 0, chr = 0; text[chr];)
++   for (char_index = 0, c = 0, chr = 0; text[chr]; char_index++)
+      {
+ 	FT_UInt index;
+ 	RGBA_Font_Glyph *fg;
+@@ -196,11 +220,25 @@
+ 	/* hmmm kerning means i can't sanely do my own cached metric tables! */
+ 	/* grrr - this means font face sharing is kinda... not an option if */
+ 	/* you want performance */
+-        if ((use_kerning) && (prev_index) && (index) &&
+-	    (pface == fi->src->ft.face))
+-	  if (evas_common_font_query_kerning(fi, prev_index, index, &kern))
+-	    pen_x += kern;
++	  if ((use_kerning) && (prev_index) && (index) &&
++	     (pface == fi->src->ft.face)) {		  
++#ifdef INTERNATIONAL_SUPPORT
++	    /* if it's rtl, the kerning matching should be reversed, i.e prev
++	    * index is now the index and the other way around. */
++	    if (evas_intl_is_rtl_char(level_list, char_index)) {
++	      if (evas_common_font_query_kerning(fi, index, prev_index, &kern)) 
++  	       pen_x += kern;
++  	    }
++	    else
++#endif
+ 
++	    {
++
++	      if (evas_common_font_query_kerning(fi, prev_index, index, &kern)) 
++	        pen_x += kern;  
++	    }
++	  }
++
+ 	pface = fi->src->ft.face;
+ 	fg = evas_common_font_int_cache_glyph_get(fi, index);
+ 	if (!fg) continue;
+@@ -347,6 +385,12 @@
+ 	pen_x += fg->glyph->advance.x >> 16;
+ 	prev_index = index;
+      }
++#ifdef INTERNATIONAL_SUPPORT
++   if (bidi_err < 0) {
++   	free(level_list);
++   	free(text);
++   }
++#endif
+ }
+ 
+ EAPI void
+Index: evas/src/lib/engines/common/evas_intl/evas_intl_arabic.c
+===================================================================
+--- evas/src/lib/engines/common/evas_intl/evas_intl_arabic.c	(revision 0)
++++ evas/src/lib/engines/common/evas_intl/evas_intl_arabic.c	(revision 0)
+@@ -0,0 +1,314 @@
++/* Authors:
++ * 	Tom Hacohen (tom@stsob.com)
++ */
++
++#include "../evas_intl_utils.h"
++
++#ifdef ARABIC_SUPPORT
++/* arabic contextualizing */
++
++/* arabic input forms */
++#define ARABIC_ALEPH_MADDA	0x0622
++#define ARABIC_ALEPH		0x0627
++#define ARABIC_BET		0x0628
++#define ARABIC_TA_MARBUTA	0x0629
++#define ARABIC_TAW		0x062A
++#define ARABIC_TA		0x062B
++#define ARABIC_GIMEL		0x062C
++#define ARABIC_HETH		0x062D
++#define ARABIC_HA		0x062E
++#define	ARABIC_DALET		0x062F
++#define ARABIC_DAL		0x0630
++#define ARABIC_RESH		0x0631
++#define ARABIC_ZAYIN		0x0632
++#define ARABIC_SHIN		0x0633
++#define ARABIC_SH		0x0634
++#define ARABIC_TSADE		0x0635
++#define ARABIC_DAD		0x0636
++#define ARABIC_TETH		0x0637
++#define ARABIC_ZA		0x0638
++#define ARABIC_AYIN		0x0639
++#define ARABIC_GHAIN		0x063A
++#define ARABIC_PE		0x0641
++#define ARABIC_QOPH		0x0642
++#define ARABIC_KAPH		0x0643
++#define ARABIC_LAMED		0x0644
++#define ARABIC_MEM		0x0645
++#define ARABIC_NUN		0x0646
++#define ARABIC_HE		0x0647
++#define ARABIC_WAW		0x0648
++#define ARABIC_ALEPH_MAQSURA	0x0649
++#define ARABIC_YODH		0x064A
++/* arabic contextual forms */
++#define ARABIC_ISOLATED_ALEPH_MADDA	0xFE81
++#define ARABIC_ISOLATED_ALEPH		0xFE8D
++#define ARABIC_ISOLATED_TA_MARBUTA	0xFE93
++#define ARABIC_ISOLATED_BET		0xFE8F
++#define ARABIC_ISOLATED_TAW		0xFE95
++#define ARABIC_ISOLATED_TA		0xFE99
++#define ARABIC_ISOLATED_GIMEL		0xFE9D
++#define ARABIC_ISOLATED_HETH		0xFEA1
++#define ARABIC_ISOLATED_HA		0xFEA5
++#define	ARABIC_ISOLATED_DALET		0xFEA9
++#define ARABIC_ISOLATED_DAL		0xFEAB
++#define ARABIC_ISOLATED_RESH		0xFEAD
++#define ARABIC_ISOLATED_ZAYIN		0xFEAF
++#define ARABIC_ISOLATED_SHIN		0xFEB1
++#define ARABIC_ISOLATED_SH		0xFEB5
++#define ARABIC_ISOLATED_TSADE		0xFEB9
++#define ARABIC_ISOLATED_DAD		0xFEBD
++#define ARABIC_ISOLATED_TETH		0xFEC1
++#define ARABIC_ISOLATED_ZA		0xFEC5
++#define ARABIC_ISOLATED_AYIN		0xFEC9
++#define ARABIC_ISOLATED_GHAIN		0xFECD
++#define ARABIC_ISOLATED_PE		0xFED1
++#define ARABIC_ISOLATED_QOPH		0xFED5
++#define ARABIC_ISOLATED_KAPH		0xFED9
++#define ARABIC_ISOLATED_LAMED		0xFEDD
++#define ARABIC_ISOLATED_MEM		0xFEE1
++#define ARABIC_ISOLATED_NUN		0xFEE5
++#define ARABIC_ISOLATED_HE		0xFEE9
++#define ARABIC_ISOLATED_WAW		0xFEED
++#define ARABIC_ISOLATED_ALEPH_MAQSURA	0xFEEF
++#define ARABIC_ISOLATED_YODH		0xFEF1
++
++#define ARABIC_IS_SPECIAL_LETTER(c)	((c) == ARABIC_ISOLATED_ALEPH ||  \
++					  (c) == ARABIC_ISOLATED_DALET || \
++					  (c) == ARABIC_ISOLATED_DAL ||   \
++					  (c) == ARABIC_ISOLATED_RESH ||  \
++					  (c) == ARABIC_ISOLATED_ZAYIN || \
++					  (c) == ARABIC_ISOLATED_WAW  || \
++					  (c) == ARABIC_ISOLATED_TA_MARBUTA)
++/* from the first to last (including all forms, and special cases
++ * like aleph maqsura in some forms*/
++#define ARABIC_IS_CONTEXT(c)	(((c) >= ARABIC_ISOLATED_ALEPH && (c) <= ARABIC_ISOLATED_YODH + 3) || \
++				 ((c) >= ARABIC_ISOLATED_ALEPH_MADDA && (c) <= ARABIC_ISOLATED_ALEPH_MADDA + 3) || \
++				 (c) == 0xFBE8 || \
++				 (c) == 0xFBE9) 
++#define ARABIC_IS_LETTER(c)	ARABIC_IS_CONTEXT(c)
++/* used for arabic context logic */
++/* each value is the offset from the regular char in unicode */
++enum _ArabicContext {
++		ARABIC_CONTEXT_ISOLATED = 0,
++		ARABIC_CONTEXT_FINAL = 1,
++		ARABIC_CONTEXT_INITIAL = 2,
++		ARABIC_CONTEXT_MEDIAL = 3
++};
++typedef enum _ArabicContext ArabicContext;
++
++static FriBidiChar
++_evas_intl_arabic_isolated_to_context(FriBidiChar chr, ArabicContext context);
++
++static int
++_evas_intl_arabic_text_to_isolated(FriBidiChar *text);
++
++static FriBidiChar
++_evas_intl_arabic_general_to_isolated(FriBidiChar chr);
++
++/* FIXME: there are issues with text that's already in context
++ * vowels support is needed (skip them when analysing context)*/
++int
++evas_intl_arabic_to_context(FriBidiChar *text)
++{
++	int i;
++	int len;
++	int start_of_context = 1; /* assume the first is special/non arabic */
++	int last_is_first = 0;
++	int last_letter = 0;
++	
++	/* check for empty string */
++	if (!*text)
++		return;
++
++	len = _evas_intl_arabic_text_to_isolated(text);
++	/*FIXME: make it skip vowels */
++	for (i = 0 ; i < len ; i++)  {
++
++		if (! ARABIC_IS_LETTER(text[i])) {
++			/* mark so it won't be touched,
++			 * though start formating */
++			if (last_letter && !start_of_context) {
++				ArabicContext tmp = (last_is_first) ?
++					ARABIC_CONTEXT_ISOLATED
++					:
++					ARABIC_CONTEXT_FINAL;
++				text[i-1] = _evas_intl_arabic_isolated_to_context(
++					last_letter,
++					tmp);
++				
++			}
++			last_is_first = 0;
++			start_of_context = 1;
++			last_letter = 0;
++			continue;
++		}
++		/* adjust the last letter */
++		last_letter = text[i];
++		if (ARABIC_IS_SPECIAL_LETTER(text[i])) {
++			if (!start_of_context) 
++				text[i] = _evas_intl_arabic_isolated_to_context(text[i], ARABIC_CONTEXT_FINAL);
++			/* else: leave isolated */
++				
++			start_of_context = 1;
++			last_is_first = 0;
++			continue;
++		}
++
++		if (start_of_context) {
++			text[i] = _evas_intl_arabic_isolated_to_context(text[i], ARABIC_CONTEXT_INITIAL);
++			last_is_first = 1;
++		}
++		else {
++			text[i] = _evas_intl_arabic_isolated_to_context(text[i], ARABIC_CONTEXT_MEDIAL);
++			last_is_first = 0;
++		}
++		/* spceial chars don't get here. */
++		start_of_context = 0;
++		
++	}
++	/* if it's arabic and not isolated, the last is always final */
++	i--;
++	if (last_letter && !start_of_context) {
++				ArabicContext tmp = (last_is_first) ? ARABIC_CONTEXT_ISOLATED : ARABIC_CONTEXT_FINAL;
++				/* because it's medial atm, and should be isolated */
++				text[i] = _evas_intl_arabic_isolated_to_context(
++					last_letter,
++					tmp);
++			}
++
++	return len;
++}
++
++/* I wish I could think about a simpler way to do it.
++ * Just match every word with it's isolated form */
++static FriBidiChar
++_evas_intl_arabic_general_to_isolated(FriBidiChar chr)
++{
++	switch (chr) {
++		case ARABIC_ALEPH_MADDA:
++			return ARABIC_ISOLATED_ALEPH_MADDA;
++
++		case ARABIC_ALEPH:
++			return ARABIC_ISOLATED_ALEPH;
++
++		case ARABIC_TA_MARBUTA:
++			return ARABIC_ISOLATED_TA_MARBUTA;
++		case ARABIC_BET:
++			return ARABIC_ISOLATED_BET;
++		
++		case ARABIC_TAW:
++			return ARABIC_ISOLATED_TAW;
++
++		case ARABIC_TA:
++			return ARABIC_ISOLATED_TA;
++		
++		case ARABIC_GIMEL:
++			return ARABIC_ISOLATED_GIMEL;
++		
++		case ARABIC_HETH:
++			return ARABIC_ISOLATED_HETH;
++		
++		case ARABIC_HA:
++			return ARABIC_ISOLATED_HA;
++		
++		case ARABIC_DALET:
++			return ARABIC_ISOLATED_DALET;
++		
++		case ARABIC_DAL:
++			return ARABIC_ISOLATED_DAL;
++		
++		case ARABIC_RESH:
++			return ARABIC_ISOLATED_RESH;
++		
++		case ARABIC_ZAYIN:
++			return ARABIC_ISOLATED_ZAYIN;
++		
++		case ARABIC_SHIN:
++			return ARABIC_ISOLATED_SHIN;
++		
++		case ARABIC_SH:
++			return ARABIC_ISOLATED_SH;
++		
++		case ARABIC_TSADE:
++			return ARABIC_ISOLATED_TSADE;
++		
++		case ARABIC_DAD:
++			return ARABIC_ISOLATED_DAD;
++		
++		case ARABIC_TETH:
++			return ARABIC_ISOLATED_TETH;
++		
++		case ARABIC_ZA:
++			return ARABIC_ISOLATED_ZA;
++		
++		case ARABIC_AYIN:
++			return ARABIC_ISOLATED_AYIN;
++		
++		case ARABIC_GHAIN:
++			return ARABIC_ISOLATED_GHAIN;
++		
++		case ARABIC_PE:
++			return ARABIC_ISOLATED_PE;
++		
++		case ARABIC_QOPH:
++			return ARABIC_ISOLATED_QOPH;
++		
++		case ARABIC_KAPH:
++			return ARABIC_ISOLATED_KAPH;
++		
++		case ARABIC_LAMED:
++			return ARABIC_ISOLATED_LAMED;
++
++		case ARABIC_MEM:
++			return ARABIC_ISOLATED_MEM;
++		
++		case ARABIC_NUN:
++			return ARABIC_ISOLATED_NUN;
++		
++		case ARABIC_HE:
++			return ARABIC_ISOLATED_HE;
++		
++		case ARABIC_WAW:
++			return ARABIC_ISOLATED_WAW;
++
++		case ARABIC_ALEPH_MAQSURA:
++			return ARABIC_ISOLATED_ALEPH_MAQSURA;
++		
++		case ARABIC_YODH:
++			return ARABIC_ISOLATED_YODH;
++		default:
++			return chr;
++	}
++}
++
++static FriBidiChar
++_evas_intl_arabic_isolated_to_context(FriBidiChar chr, ArabicContext context)
++{
++	if (ARABIC_IS_SPECIAL_LETTER(chr)) {
++		if (context == ARABIC_CONTEXT_INITIAL)
++			return chr;
++		else
++			return chr + ARABIC_CONTEXT_FINAL;
++	}
++	/* HACK AROUND ALIF MAQSURA */
++	else if (chr == ARABIC_ISOLATED_ALEPH_MAQSURA && context > 1) {
++		chr = 0xFBE8; /* the initial form */
++		context -= 2;
++	}
++	return chr + context;
++}
++
++static int
++_evas_intl_arabic_text_to_isolated(FriBidiChar *text)
++{
++	int i=0;
++	while (*text) {
++		/* if it's not arabic/it's already in context
++		 * it's just returned the same */
++		*text = _evas_intl_arabic_general_to_isolated(*text);
++		text++;
++		i++;
++	}
++	return i;
++}
++#endif
+\ No newline at end of file
+Index: evas/src/lib/engines/common/evas_intl/evas_intl_arabic.h
+===================================================================
+--- evas/src/lib/engines/common/evas_intl/evas_intl_arabic.h	(revision 0)
++++ evas/src/lib/engines/common/evas_intl/evas_intl_arabic.h	(revision 0)
+@@ -0,0 +1,7 @@
++#ifndef _EVAS_INTL_ARABIC
++#define _EVAS_INTL_ARABIC
++
++int
++evas_intl_arabic_to_context(FriBidiChar *text);
++
++#endif
+Index: evas/src/lib/engines/common/evas_intl_utils.c
+===================================================================
+--- evas/src/lib/engines/common/evas_intl_utils.c	(revision 0)
++++ evas/src/lib/engines/common/evas_intl_utils.c	(revision 0)
+@@ -0,0 +1,104 @@
++/* Authors:
++ * 	Tom Hacohen (tom@stsob.com)
++ */
++
++#include <string.h>
++#include <stdlib.h>
++
++#include "evas_intl_utils.h"
++
++#ifdef USE_FRIBIDI
++#include <fribidi/fribidi.h>
++
++#define UTF8_BYTES_PER_CHAR 4
++
++/* FIXME: fribidi_utf8_to_unicode should use char len and not byte len!*/
++char *
++evas_intl_utf8_to_visual(const char *text, int *ret_len, FriBidiCharType *direction,
++			FriBidiLevel **embedding_level_list)
++{
++	FriBidiChar *unicode_in, *unicode_out;
++	char *text_out;
++	size_t len;
++	size_t byte_len;
++
++	if (!text)
++		return NULL;
++
++	len = evas_string_char_len_get(text);
++
++	/* if there's nothing to do, return text
++	 * one char draws are quite common */
++	if (len <= 1)
++		return text;
++	
++	byte_len = strlen(text); /* we need the actual number of bytes, not number of chars */
++	
++	unicode_in=(FriBidiChar *)malloc(sizeof(FriBidiChar)*(len+1));
++	if (!unicode_in) {
++		len = -1;
++		goto error1;
++		
++	}
++		
++	len = fribidi_utf8_to_unicode(text, byte_len, unicode_in);
++	
++	unicode_out=(FriBidiChar *)malloc(sizeof(FriBidiChar)*(len+1));
++	if (!unicode_out) {
++		len = -2;
++		goto error2;
++		
++	}
++
++	*embedding_level_list=(FriBidiLevel *)malloc(sizeof(FriBidiLevel)*len);
++	if (!*embedding_level_list) {
++		len = -3;
++		goto error3;
++		
++	}
++
++#ifdef ARABIC_SUPPORT
++	/* fix arabic context */
++	evas_intl_arabic_to_context(unicode_in);
++#endif	
++	if (! fribidi_log2vis(unicode_in, len, direction,
++			unicode_out, NULL, NULL, *embedding_level_list)) {
++		len = -4;
++		goto error3;
++				
++	}
++
++	text_out = malloc(UTF8_BYTES_PER_CHAR * len + 1);
++	if (!text_out) {
++		len = -5;
++		goto error4;
++	}
++
++	fribidi_unicode_to_utf8(unicode_out, len, text_out);
++	
++	free(unicode_in);
++	free(unicode_out);
++
++	*ret_len = len;
++	return text_out;
++
++	/* ERROR HANDLING */
++error4:
++	free(unicode_out);
++error3:
++	free(*embedding_level_list);
++error2:
++	free(unicode_in);
++error1:
++
++	*ret_len = len;	
++	return NULL;
++}
++
++
++int
++evas_intl_is_rtl_char(FriBidiLevel *embedded_level_list, FriBidiStrIndex i)
++{
++	return fribidi_is_char_rtl(embedded_level_list, 0, i);
++}
++#endif
+Index: evas/src/lib/engines/common/evas_intl_utils.h
+===================================================================
+--- evas/src/lib/engines/common/evas_intl_utils.h	(revision 0)
++++ evas/src/lib/engines/common/evas_intl_utils.h	(revision 0)
+@@ -0,0 +1,29 @@
++#ifndef _EVAS_INTL_UTILS
++#define _EVAS_INTL_UTILS
++
++#include "config.h"
++
++#ifdef HAVE_FRIBIDI_FRIBIDI_H
++#define USE_FRIBIDI 1
++#define INTERNATIONAL_SUPPORT
++#endif
++
++#ifdef USE_FRIBIDI
++#include <fribidi/fribidi.h>
++
++/* whether should fix arabic specifix issues */
++#define ARABIC_SUPPORT 1
++
++#ifdef ARABIC_SUPPORT
++#include "evas_intl/evas_intl_arabic.h"
++#endif
++
++int
++evas_intl_is_rtl_char(FriBidiLevel *embedded_level_list, FriBidiStrIndex i);
++
++char *
++evas_intl_utf8_to_visual(const char *text, int *ret_len, FriBidiCharType *direction,
++			FriBidiLevel **embedding_level_list);
++#endif
++
++#endif
+Index: evas/src/lib/engines/common/Makefile.am
+===================================================================
+--- evas/src/lib/engines/common/Makefile.am	(revision 39827)
++++ evas/src/lib/engines/common/Makefile.am	(working copy)
+@@ -13,6 +13,9 @@
+ 		       @EET_CFLAGS@ @pthread_cflags@ \
+ 		       @WIN32_CFLAGS@ @EINA_CFLAGS@
+ 
++libevas_engine_common_la_CFLAGS  = @FRIBIDI_CFLAGS@ 
++libevas_engine_common_la_LDFLAGS  = @FRIBIDI_LIBS@
++
+ noinst_LTLIBRARIES      = libevas_engine_common.la
+ libevas_engine_common_la_SOURCES  = \
+ evas_op_copy_main_.c \
+@@ -63,7 +66,9 @@
+ evas_scale_span.c \
+ evas_tiler.c \
+ evas_regionbuf.c \
+-evas_pipe.c
++evas_pipe.c \
++evas_intl_utils.c \
++evas_intl/evas_intl_arabic.c
+ 
+ EXTRA_DIST = \
+ evas_blend.h \
+@@ -98,7 +103,7 @@
+ evas_scale_smooth_scaler_noscale.c \
+ evas_scale_smooth_scaler_up.c \
+ evas_scale_span.h \
+-evas_pipe.h
++evas_pipe.h 
+ 
+ libevas_engine_common_la_DEPENDENCIES = \
+ $(top_builddir)/config.h
+Index: evas/configure.ac
+===================================================================
+--- evas/configure.ac	(revision 39827)
++++ evas/configure.ac	(working copy)
+@@ -137,6 +137,10 @@
+   [use_strict="no"]
+ )
+ 
++##################################################################
++#fribidi support - OPTIONAL!
++PKG_CHECK_MODULES([FRIBIDI], [fribidi], ,HAS_BIDI=0)
++AC_CHECK_HEADERS(fribidi/fribidi.h)
+ #####################################################################
+ # Check evas strong dependencie
+ 
diff --git a/recipes/efl1/evas_svn.bb b/recipes/efl1/evas_svn.bb
index 02d4cf4..7c6605e 100644
--- a/recipes/efl1/evas_svn.bb
+++ b/recipes/efl1/evas_svn.bb
@@ -1,5 +1,5 @@
 require evas.inc
-PR = "r1"
+PR = "r1.3"
 
 EXTRA_OECONF = "\
 		--x-includes=${STAGING_INCDIR}/X11  \
-- 
1.6.2.2

